import base64
import cv2
import numpy as np
from PIL import Image
from io import BytesIO

def base64_to_rgb(base64_str):
    if base64_str.startswith("data:image"):
        base64_str = base64_str.split(",")[1]
    img_data = base64.b64decode(base64_str)
    img = Image.open(BytesIO(img_data))

    if img.mode == 'RGBA':
        img = img.convert('RGB')
    elif img.mode == 'L':
        img = img.convert('RGB')
    elif img.mode != 'RGB':
        img = img.convert('RGB')

    rgb_array = np.array(img)
    bgr_image = cv2.cvtColor(rgb_array, cv2.COLOR_RGB2BGR)
    return bgr_image

def crop_to_24x24(bgr_image):
    h, w = bgr_image.shape[:2]

    # 计算中心裁剪的起始坐标
    start_y = max(0, (h - 24) // 2)
    start_x = max(0, (w - 24) // 2)

    # 执行裁剪
    cropped_img = bgr_image[start_y:start_y+24, start_x:start_x+24]

    # 如果图像尺寸小于24x24，填充到目标尺寸
    if cropped_img.shape[0] < 24 or cropped_img.shape[1] < 24:
        pad_y = (24 - cropped_img.shape[0]) // 2
        pad_x = (24 - cropped_img.shape[1]) // 2
        cropped_img = cv2.copyMakeBorder(
            cropped_img,
            pad_y,
            24 - cropped_img.shape[0] - pad_y,
            pad_x,
            24 - cropped_img.shape[1] - pad_x,
            cv2.BORDER_CONSTANT,
            value=[0, 0, 0]
        )

    return cropped_img

# 使用示例
base64_str = "your_base64_string_here"
bgr_img = base64_to_rgb(base64_str)
cropped_24x24 = crop_to_24x24(bgr_img)

# 检查结果尺寸
print("裁剪后图像尺寸:", cropped_24x24.shape)  # 应输出 (24, 24, 3)